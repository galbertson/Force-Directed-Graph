<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Force-Directed Graph Editor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
    }
    .graph-container {
      background-color: #f0f0f0;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    h2 {
      text-align: center;
      margin-bottom: 20px;
    }
    h3 {
      margin-top: 0;
    }
    svg {
      background-color: #1a1a2e;
      border-radius: 8px;
      display: block;
      margin: 0 auto;
      width: 100%;
      height: 500px;
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    .control-panel {
      background-color: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    input, select, button {
      display: block;
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    button {
      background-color: #4a69bd;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 0.2s;
    }
    button:hover {
      background-color: #1e3799;
    }
    button.remove {
      background-color: #eb4d4b;
    }
    button.remove:hover {
      background-color: #c0392b;
    }
    button.export, button.save {
      background-color: #6ab04c;
    }
    button.export:hover, button.save:hover {
      background-color: #4a9e2d;
    }
    button.load {
      background-color: #f0932b;
    }
    button.load:hover {
      background-color: #d68529;
    }
    .import-label {
      background-color: #8e44ad;
      color: white;
      padding: 8px;
      border-radius: 4px;
      cursor: pointer;
      text-align: center;
      font-weight: 600;
      display: inline-block;
      width: 100%;
      box-sizing: border-box;
    }
    .import-label:hover {
      background-color: #6c3483;
    }
    .hidden {
      display: none;
    }
    .bottom-controls {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    .bottom-controls button, .bottom-controls .import-label {
      flex: 1;
    }
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      width: 400px;
      max-width: 90%;
      position: relative;
    }
    .modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
      cursor: pointer;
      width: auto;
      background: none;
      border: none;
      color: #555;
    }
    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 15px;
    }
    .modal-buttons button {
      width: auto;
      padding: 8px 15px;
    }
    button.cancel {
      background-color: #95a5a6;
    }
    button.cancel:hover {
      background-color: #7f8c8d;
    }
    .messages {
      background-color: #fff;
      padding: 10px;
      margin-top: 10px;
      border-radius: 4px;
      border-left: 4px solid #3498db;
    }
    .error {
      border-left-color: #e74c3c;
    }
    .success {
      border-left-color: #2ecc71;
    }
    @media (max-width: 768px) {
      .controls {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="graph-container">
      <h2>Force-Directed Graph Editor</h2>
      
      <svg id="graph"></svg>
      
      <div id="messages" class="messages hidden"></div>
      
      <div class="controls">
        <div class="control-panel">
          <h3>Add Node</h3>
          <input type="text" id="newNodeName" placeholder="New Node Name">
          <select id="parentSelect"></select>
          <button id="addNodeBtn">Add Node</button>
        </div>
        
        <div class="control-panel">
          <h3>Remove Node</h3>
          <select id="removeNodeSelect">
            <option value="">Select Node to Remove</option>
          </select>
          <button id="removeNodeBtn" class="remove">Remove Node</button>
        </div>
      </div>
      
      <div class="bottom-controls">
        <button id="saveBtn" class="save">Save to Local Storage</button>
        <button id="loadBtn" class="load">Load from Local Storage</button>
        <button id="exportBtn" class="export">Export JSON</button>
        <label class="import-label">
          Import JSON
          <input type="file" id="importInput" accept=".json" class="hidden">
        </label>
      </div>
    </div>
  </div>
  
  <div id="editModal" class="modal hidden">
    <div class="modal-content">
      <button class="modal-close" id="closeModalBtn">&times;</button>
      <h3 id="editModalTitle">Edit Node</h3>
      <input type="text" id="nodeLabelEdit" placeholder="Node Label">
      <div class="modal-buttons">
        <button id="cancelEditBtn" class="cancel">Cancel</button>
        <button id="updateNodeBtn">Update</button>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Initial data
      let nodes = [
        { id: "Root", group: 0, label: "Root", val: 20 },
        { id: "Child1", group: 1, label: "Child 1", val: 15 },
        { id: "Child2", group: 1, label: "Child 2", val: 15 },
        { id: "Child3", group: 1, label: "Child 3", val: 15 },
        { id: "Grandchild1", group: 2, label: "Grandchild 1", val: 10 },
        { id: "Grandchild2", group: 2, label: "Grandchild 2", val: 10 },
        { id: "Grandchild3", group: 2, label: "Grandchild 3", val: 10 },
        { id: "Grandchild4", group: 2, label: "Grandchild 4", val: 10 },
        { id: "Grandchild5", group: 2, label: "Grandchild 5", val: 10 },
      ];
      
      let links = [
        { source: "Root", target: "Child1", value: 2 },
        { source: "Root", target: "Child2", value: 2 },
        { source: "Root", target: "Child3", value: 2 },
        { source: "Child1", target: "Grandchild1", value: 1 },
        { source: "Child1", target: "Grandchild2", value: 1 },
        { source: "Child2", target: "Grandchild3", value: 1 },
        { source: "Child2", target: "Grandchild4", value: 1 },
        { source: "Child3", target: "Grandchild5", value: 1 },
      ];

      let selectedNode = null;
      const colors = d3.scaleOrdinal(d3.schemeCategory10);
      
      // DOM elements
      const svg = d3.select("#graph");
      const newNodeNameInput = document.getElementById('newNodeName');
      const parentSelect = document.getElementById('parentSelect');
      const removeNodeSelect = document.getElementById('removeNodeSelect');
      const addNodeBtn = document.getElementById('addNodeBtn');
      const removeNodeBtn = document.getElementById('removeNodeBtn');
      const exportBtn = document.getElementById('exportBtn');
      const importInput = document.getElementById('importInput');
      const saveBtn = document.getElementById('saveBtn');
      const loadBtn = document.getElementById('loadBtn');
      const editModal = document.getElementById('editModal');
      const editModalTitle = document.getElementById('editModalTitle');
      const nodeLabelEdit = document.getElementById('nodeLabelEdit');
      const cancelEditBtn = document.getElementById('cancelEditBtn');
      const updateNodeBtn = document.getElementById('updateNodeBtn');
      const closeModalBtn = document.getElementById('closeModalBtn');
      const messagesEl = document.getElementById('messages');
      
      // Initialize the graph
      initGraph();
      
      // Try to load data from localStorage on page load
      tryLoadFromLocalStorage();
      
      // Event listeners
      addNodeBtn.addEventListener('click', addNode);
      removeNodeBtn.addEventListener('click', removeNode);
      exportBtn.addEventListener('click', exportData);
      importInput.addEventListener('change', importData);
      saveBtn.addEventListener('click', saveToLocalStorage);
      loadBtn.addEventListener('click', loadFromLocalStorage);
      
      // Modal event listeners
      closeModalBtn.addEventListener('click', closeEditModal);
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && !editModal.classList.contains('hidden')) {
          closeEditModal();
        }
      });
      
      editModal.addEventListener('click', (event) => {
        if (event.target === editModal) {
          closeEditModal();
        }
      });
      
      cancelEditBtn.addEventListener('click', closeEditModal);
      updateNodeBtn.addEventListener('click', updateNodeLabel);
      
      function closeEditModal() {
        editModal.classList.add('hidden');
        selectedNode = null;
      }

      // Initialize the graph
      function initGraph() {
        updateSelectOptions();
        renderGraph();
      }
      
      // Show a message to the user
      function showMessage(message, type = '') {
        messagesEl.textContent = message;
        messagesEl.className = `messages ${type}`;
        messagesEl.classList.remove('hidden');
        
        setTimeout(() => {
          messagesEl.classList.add('hidden');
        }, 3000);
      }
      
      // Update the select options for parent and remove dropdowns
      function updateSelectOptions() {
        // Clear existing options
        parentSelect.innerHTML = '';
        removeNodeSelect.innerHTML = '<option value="">Select Node to Remove</option>';
        
        // Add new options based on current nodes
        nodes.forEach(node => {
          const parentOption = document.createElement('option');
          parentOption.value = node.id;
          parentOption.textContent = node.label;
          parentSelect.appendChild(parentOption);
          
          const removeOption = document.createElement('option');
          removeOption.value = node.id;
          removeOption.textContent = node.label;
          removeNodeSelect.appendChild(removeOption);
        });
      }
      
      // Render the force-directed graph
      function renderGraph() {
        // Clear SVG
        svg.selectAll('*').remove();
        
        // Calculate dimensions
        const width = parseInt(svg.style('width'));
        const height = parseInt(svg.style('height'));
        
        // Set up the simulation
        const simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d => d.id).distance(100))
          .force("charge", d3.forceManyBody().strength(-300))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collide", d3.forceCollide().radius(d => d.val + 10));
        
        // Draw the links
        const link = svg.append("g")
          .selectAll("line")
          .data(links)
          .enter()
          .append("line")
          .attr("stroke", "#999")
          .attr("stroke-width", d => Math.sqrt(d.value));
        
        // Draw the nodes
        const node = svg.append("g")
          .selectAll("g")
          .data(nodes)
          .enter()
          .append("g")
          .call(drag(simulation))
          .on("click", function(event, d) {
            event.stopPropagation();
            selectedNode = d;
            editModalTitle.textContent = `Edit Node: ${d.label}`;
            nodeLabelEdit.value = d.label;
            editModal.classList.remove('hidden');
          });
        
        // Add circles to the node groups
        node.append("circle")
          .attr("r", d => d.val)
          .attr("fill", d => colors(d.group))
          .attr("stroke", "#fff")
          .attr("stroke-width", 1.5);
        
        // Add labels to the node groups
        node.append("text")
          .attr("text-anchor", "middle")
          .attr("dy", ".35em")
          .text(d => d.label)
          .attr("fill", "#fff")
          .style("font-size", "12px")
          .style("pointer-events", "none");
        
        // Set up the simulation tick function
        simulation.on("tick", () => {
          link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);
          
          node.attr("transform", d => `translate(${d.x},${d.y})`);
        });
        
        // Helper function for dragging
        function drag(simulation) {
          function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
          }
          
          function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
          }
          
          function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
          }
          
          return d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);
        }
      }
      
      // Add a new node
      function addNode() {
        const newNodeName = newNodeNameInput.value.trim();
        const selectedParent = parentSelect.value;
        
        if (!newNodeName) {
          showMessage('Please enter a node name', 'error');
          return;
        }
        
        const existingNode = nodes.find(node => node.id === newNodeName);
        if (existingNode) {
          showMessage('A node with this ID already exists', 'error');
          return;
        }
        
        const parentNode = nodes.find(node => node.id === selectedParent);
        if (!parentNode) {
          showMessage('Please select a parent node', 'error');
          return;
        }
        
        const newNode = {
          id: newNodeName,
          label: newNodeName,
          group: parentNode.group + 1,
          val: Math.max(parentNode.val - 5, 5)
        };
        
        const newLink = {
          source: selectedParent,
          target: newNodeName,
          value: 1
        };
        
        nodes.push(newNode);
        links.push(newLink);
        newNodeNameInput.value = '';
        
        showMessage(`Added new node: ${newNodeName}`, 'success');
        updateSelectOptions();
        renderGraph();
      }
      
      // Remove a node
      function removeNode() {
        const nodeToRemove = removeNodeSelect.value;
        
        if (!nodeToRemove) {
          showMessage('Please select a node to remove', 'error');
          return;
        }
        
        if (nodeToRemove === "Root") {
          showMessage('Cannot remove the root node', 'error');
          return;
        }
        
        // Find all descendants of the node to remove
        const nodesToRemove = new Set();
        nodesToRemove.add(nodeToRemove);
        
        let found = true;
        while (found) {
          found = false;
          for (const link of links) {
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            
            if (nodesToRemove.has(sourceId) && !nodesToRemove.has(targetId)) {
              nodesToRemove.add(targetId);
              found = true;
            }
          }
        }
        
        // Remove all affected nodes and links
        const originalLength = nodes.length;
        nodes = nodes.filter(node => !nodesToRemove.has(node.id));
        links = links.filter(link => {
          const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
          const targetId = typeof link.target === 'object' ? link.target.id : link.target;
          return !nodesToRemove.has(sourceId) && !nodesToRemove.has(targetId);
        });
        
        const removedCount = originalLength - nodes.length;
        showMessage(`Removed ${removedCount} node(s)`, 'success');
        updateSelectOptions();
        renderGraph();
      }
      
      // Update node label
      function updateNodeLabel() {
        if (!selectedNode) return;
        
        const newLabel = nodeLabelEdit.value.trim();
        if (!newLabel) {
          showMessage('Please enter a node label', 'error');
          return;
        }
        
        nodes = nodes.map(node => {
          if (node.id === selectedNode.id) {
            return { ...node, label: newLabel };
          }
          return node;
        });
        
        showMessage(`Updated node: ${selectedNode.id}`, 'success');
        closeEditModal();
        updateSelectOptions();
        renderGraph();
      }
      
      // Save data to localStorage
      function saveToLocalStorage() {
        try {
          const data = {
            nodes: nodes,
            links: links
          };
          
          localStorage.setItem('graphEditorData', JSON.stringify(data));
          showMessage('Data saved to local storage', 'success');
        } catch (error) {
          showMessage('Error saving data: ' + error.message, 'error');
        }
      }
      
      // Try to load data from localStorage on page load
      function tryLoadFromLocalStorage() {
        try {
          const savedData = localStorage.getItem('graphEditorData');
          if (savedData) {
            const data = JSON.parse(savedData);
            loadGraphData(data);
          }
        } catch (error) {
          console.error('Error loading saved data:', error);
        }
      }
      
      // Load data from localStorage with confirmation
      function loadFromLocalStorage() {
        try {
          const savedData = localStorage.getItem('graphEditorData');
          if (!savedData) {
            showMessage('No saved data found', 'error');
            return;
          }
          
          const data = JSON.parse(savedData);
          loadGraphData(data);
          showMessage('Data loaded from local storage', 'success');
        } catch (error) {
          showMessage('Error loading data: ' + error.message, 'error');
        }
      }
      
      // Load graph data from a data object
      function loadGraphData(data) {
        if (data.nodes && data.links) {
          nodes = data.nodes;
          links = data.links.map(link => ({
            source: link.source.id || link.source,
            target: link.target.id || link.target,
            value: link.value || 1
          }));
          
          updateSelectOptions();
          renderGraph();
        }
      }
      
      // Export data as JSON
      function exportData() {
        const data = {
          nodes: nodes,
          links: links
        };
        
        const jsonString = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonString], { type: "application/json" });
        const href = URL.createObjectURL(blob);
        
        const link = document.createElement("a");
        link.href = href;
        link.download = "force-directed-graph-data.json";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      
      // Import data from JSON file
      function importData(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            loadGraphData(data);
            showMessage('Data imported successfully', 'success');
          } catch (error) {
            showMessage('Error importing data: ' + error.message, 'error');
          }
        };
        reader.readAsText(file);
      }
    });
    // Close modal if clicking outside of it
document.addEventListener("click", (event) => {
  if (
    !editModal.classList.contains("hidden") &&
    !editModal.contains(event.target) &&
    event.target.id !== "updateNodeBtn"
  ) {
    editModal.classList.add("hidden");
    selectedNode = null;
  }
});

// Prevent clicks inside the modal from closing it
editModal.addEventListener("click", (event) => {
  event.stopPropagation();
});
  </script>
</body>
</html>
